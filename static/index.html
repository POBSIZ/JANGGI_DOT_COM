<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ïû•Í∏∞ AI ÏóîÏßÑ</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;700&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }

      .container {
        background: linear-gradient(145deg, #2d2d44 0%, #1f1f35 100%);
        border-radius: 24px;
        padding: 32px;
        box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        max-width: 1400px;
        width: 100%;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      h1 {
        text-align: center;
        color: #e8d5b7;
        margin-bottom: 28px;
        font-size: 2.4em;
        font-weight: 300;
        letter-spacing: 4px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .controls {
        display: flex;
        gap: 12px;
        margin-bottom: 24px;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        padding: 14px 28px;
        font-size: 15px;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        background: linear-gradient(135deg, #c9a66b 0%, #a07d4a 100%);
        color: #1a1a2e;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        font-weight: 600;
        letter-spacing: 1px;
        box-shadow: 0 4px 15px rgba(201, 166, 107, 0.3);
      }

      button:hover {
        background: linear-gradient(135deg, #d4b37a 0%, #b08d5a 100%);
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(201, 166, 107, 0.4);
      }

      button:active {
        transform: translateY(-1px);
      }

      button:disabled {
        background: #4a4a5a;
        color: #8a8a9a;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      button.secondary {
        background: linear-gradient(135deg, #4a6fa5 0%, #3a5a8a 100%);
        color: #e8e8f0;
        box-shadow: 0 4px 15px rgba(74, 111, 165, 0.3);
      }

      button.secondary:hover {
        background: linear-gradient(135deg, #5a7fb5 0%, #4a6a9a 100%);
        box-shadow: 0 8px 25px rgba(74, 111, 165, 0.4);
      }

      button.error {
        background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        color: #ffffff;
        box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
      }

      button.error:hover {
        background: linear-gradient(135deg, #e04d5d 0%, #d83343 100%);
        box-shadow: 0 8px 25px rgba(220, 53, 69, 0.4);
      }

      .multiplayer-btn {
        padding: 14px 28px;
        font-size: 15px;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        background: linear-gradient(135deg, #6c5ce7 0%, #5541d0 100%);
        color: #ffffff;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        font-weight: 600;
        letter-spacing: 1px;
        box-shadow: 0 4px 15px rgba(108, 92, 231, 0.3);
        text-decoration: none;
        display: inline-block;
      }

      .multiplayer-btn:hover {
        background: linear-gradient(135deg, #7c6cf7 0%, #6551e0 100%);
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(108, 92, 231, 0.4);
      }

      .game-info {
        text-align: center;
        margin-bottom: 24px;
      }

      .main-content {
        display: flex;
        gap: 32px;
        flex-wrap: wrap;
        justify-content: center;
        align-items: flex-start;
      }

      .board-container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .board-wrapper {
        position: relative;
        background: linear-gradient(145deg, #c9a66b 0%, #a07d4a 100%);
        padding: 20px;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4),
          inset 0 2px 4px rgba(255, 255, 255, 0.2),
          inset 0 -2px 4px rgba(0, 0, 0, 0.1);
      }

      #gameCanvas {
        display: block;
        border-radius: 8px;
        cursor: pointer;
      }

      .status {
        text-align: center;
        padding: 16px 24px;
        border-radius: 12px;
        font-size: 16px;
        font-weight: 600;
        letter-spacing: 1px;
      }

      .status.info {
        background: rgba(74, 111, 165, 0.2);
        color: #7eb3ff;
        border: 1px solid rgba(74, 111, 165, 0.3);
      }

      .status.warning {
        background: rgba(255, 193, 7, 0.15);
        color: #ffc107;
        border: 1px solid rgba(255, 193, 7, 0.3);
      }

      .status.success {
        background: rgba(40, 167, 69, 0.15);
        color: #5dd879;
        border: 1px solid rgba(40, 167, 69, 0.3);
      }

      .status.error {
        background: rgba(220, 53, 69, 0.15);
        color: #ff6b7a;
        border: 1px solid rgba(220, 53, 69, 0.3);
      }

      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
      }

      .toast {
        background: rgba(45, 45, 68, 0.95);
        backdrop-filter: blur(10px);
        padding: 16px 24px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        min-width: 300px;
        max-width: 400px;
        display: flex;
        align-items: center;
        gap: 12px;
        animation: slideIn 0.3s ease-out;
        pointer-events: auto;
        border-left: 4px solid;
      }

      .toast.error {
        border-left-color: #ff6b7a;
      }

      .toast.error .toast-icon {
        color: #ff6b7a;
      }

      .toast.success {
        border-left-color: #5dd879;
      }

      .toast.success .toast-icon {
        color: #5dd879;
      }

      .toast.info {
        border-left-color: #7eb3ff;
      }

      .toast.info .toast-icon {
        color: #7eb3ff;
      }

      .toast.warning {
        border-left-color: #ffc107;
      }

      .toast.warning .toast-icon {
        color: #ffc107;
      }

      .toast-icon {
        font-size: 20px;
        flex-shrink: 0;
      }

      .toast-content {
        flex: 1;
        font-size: 14px;
        color: #e8e8f0;
        line-height: 1.4;
      }

      .toast-close {
        background: none;
        border: none;
        font-size: 20px;
        color: #8a8a9a;
        cursor: pointer;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        transition: color 0.2s;
      }

      .toast-close:hover {
        color: #e8e8f0;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }

      .toast.hiding {
        animation: slideOut 0.3s ease-in forwards;
      }

      .move-info {
        margin-top: 16px;
        padding: 14px 18px;
        background: rgba(201, 166, 107, 0.1);
        border: 1px solid rgba(201, 166, 107, 0.2);
        border-radius: 10px;
        font-size: 14px;
        color: #e8d5b7;
      }

      .move-info strong {
        color: #c9a66b;
      }

      .side-panel {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 24px;
        border-radius: 16px;
        min-width: 280px;
        max-width: 360px;
      }

      .side-panel h3 {
        margin-bottom: 18px;
        color: #e8d5b7;
        font-size: 18px;
        font-weight: 400;
        letter-spacing: 2px;
        border-bottom: 1px solid rgba(201, 166, 107, 0.2);
        padding-bottom: 12px;
      }

      .history-panel {
        max-height: 500px;
        overflow-y: auto;
      }

      .history-panel::-webkit-scrollbar {
        width: 6px;
      }

      .history-panel::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 3px;
      }

      .history-panel::-webkit-scrollbar-thumb {
        background: rgba(201, 166, 107, 0.4);
        border-radius: 3px;
      }

      .history-item {
        padding: 10px 14px;
        margin-bottom: 8px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 8px;
        border-left: 3px solid #4a6fa5;
        font-size: 14px;
        color: #b8b8c8;
        transition: all 0.2s;
      }

      .history-item:hover {
        background: rgba(255, 255, 255, 0.06);
      }

      .history-item.capture {
        border-left-color: #ff6b7a;
      }

      .history-item strong {
        color: #c9a66b;
      }

      .formation-selector {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 18px;
      }

      .formation-option {
        padding: 14px;
        background: rgba(255, 255, 255, 0.03);
        border: 2px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .formation-option:hover {
        border-color: rgba(201, 166, 107, 0.4);
        background: rgba(201, 166, 107, 0.1);
      }

      .formation-option.selected {
        border-color: #c9a66b;
        background: rgba(201, 166, 107, 0.15);
      }

      .formation-option strong {
        display: block;
        margin-bottom: 6px;
        color: #e8d5b7;
        font-size: 14px;
      }

      .formation-option small {
        color: #8a8a9a;
        font-size: 12px;
      }

      #moveHistory:empty::after {
        content: "ÏïÑÏßÅ Ïù¥ÎèôÏù¥ ÏóÜÏäµÎãàÎã§";
        display: block;
        color: #6a6a7a;
        text-align: center;
        padding: 24px;
        font-style: italic;
      }

      .book-indicator {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        background: rgba(40, 167, 69, 0.15);
        border: 1px solid rgba(40, 167, 69, 0.3);
        border-radius: 20px;
        font-size: 12px;
        color: #5dd879;
        margin-left: 12px;
      }

      .book-indicator.inactive {
        background: rgba(138, 138, 154, 0.15);
        border-color: rgba(138, 138, 154, 0.3);
        color: #8a8a9a;
      }

      /* Î™®Î∞îÏùº Î∞òÏùëÌòï ÎîîÏûêÏù∏ */
      @media (max-width: 768px) {
        body {
          padding: 10px;
        }

        .container {
          padding: 16px;
          border-radius: 16px;
        }

        h1 {
          font-size: 1.6em;
          margin-bottom: 16px;
          letter-spacing: 2px;
        }

        .controls {
          gap: 8px;
          margin-bottom: 16px;
        }

        button {
          padding: 10px 16px;
          font-size: 13px;
          border-radius: 8px;
        }

        .main-content {
          flex-direction: column;
          gap: 16px;
        }

        .board-wrapper {
          padding: 10px;
          border-radius: 12px;
        }

        #gameCanvas {
          width: 100% !important;
          height: auto !important;
        }

        .side-panel {
          min-width: unset;
          max-width: unset;
          width: 100%;
          padding: 16px;
        }

        .history-panel {
          max-height: 200px;
        }

        .status {
          padding: 12px 16px;
          font-size: 14px;
        }

        .move-info {
          padding: 10px 14px;
          font-size: 13px;
        }

        .formation-option {
          padding: 10px;
        }

        .formation-option strong {
          font-size: 13px;
        }

        .formation-option small {
          font-size: 11px;
        }

        .toast {
          min-width: 250px;
          max-width: 300px;
          padding: 12px 16px;
        }

        .toast-container {
          right: 10px;
          top: 10px;
        }
      }

      @media (max-width: 480px) {
        h1 {
          font-size: 1.3em;
        }

        .controls {
          flex-direction: column;
        }

        button {
          width: 100%;
        }
        
        .controls-row {
          display: flex;
          gap: 8px;
          width: 100%;
        }
        
        .controls-row button {
          flex: 1;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Ïû•Í∏∞ AI ÏóîÏßÑ</h1>

      <div class="controls">
        <button id="newGameBtn">ÏÉà Í≤åÏûÑ</button>
        <button id="aiMoveBtn">AI Ïù¥Îèô</button>
        <button id="autoPlayBtn" class="secondary">AI ÏûêÎèô ÏßÑÌñâ</button>
        <button id="undoBtn" class="secondary">ÎêòÎèåÎ¶¨Í∏∞</button>
        <button id="setupBtn" class="secondary">ÏÉÅÏ∞®Î¶º ÏÑ§Ï†ï</button>
        <button id="flipBoardBtn" class="secondary">Î≥¥Îìú Îí§ÏßëÍ∏∞</button>
        <a href="/static/multiplayer.html" class="multiplayer-btn">üéÆ Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥</a>
      </div>

      <div class="game-info">
        <div id="status" class="status info">Í≤åÏûÑÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî</div>
        <span id="bookIndicator" class="book-indicator inactive" style="display: none;">
          üìñ Ï†ïÏÑùÎ∂Å
        </span>
      </div>

      <div class="main-content">
        <div class="board-container">
          <div class="board-wrapper">
            <canvas id="gameCanvas" width="520" height="580"></canvas>
          </div>
          <div id="moveInfo" class="move-info" style="display: none">
            <strong>ÏÑ†ÌÉùÌïú Í∏∞Î¨º:</strong> <span id="selectedPiece"></span><br />
            <strong>Í∞ÄÎä•Ìïú Ïù¥Îèô:</strong> <span id="possibleMoves"></span>
          </div>
        </div>

        <div class="side-panel" id="setupPanel" style="display: none">
          <h3>ÏÉÅÏ∞®Î¶º ÏÑ§Ï†ï</h3>
          
          <div style="margin-bottom: 24px;">
            <h4 style="color: #c9a66b; margin-bottom: 12px; font-size: 16px; font-weight: 600;">ÎÇ¥ ÏßÑÏòÅ ÏÑ†ÌÉù</h4>
            <div class="formation-selector" id="mySideSelector" style="display: flex; gap: 12px;">
              <div class="formation-option" data-side="cho" style="flex: 1; text-align: center; padding: 16px;">
                <strong>Ï¥à</strong>
                <small>ÎÇ¥Í∞Ä Ï¥à ÏßÑÏòÅ</small>
              </div>
              <div class="formation-option selected" data-side="han" style="flex: 1; text-align: center; padding: 16px;">
                <strong>Ìïú</strong>
                <small>ÎÇ¥Í∞Ä Ìïú ÏßÑÏòÅ</small>
              </div>
            </div>
          </div>

          <div style="margin-bottom: 24px;">
            <h4 style="color: #c9a66b; margin-bottom: 12px; font-size: 16px; font-weight: 600;" id="myFormationLabel">ÎÇòÏùò ÏÉÅÏ∞®Î¶º (Ìïú Ï∏°)</h4>
            <div class="formation-selector" id="myFormationSelector">
              <div class="formation-option" data-formation="ÏÉÅÎßàÏÉÅÎßà" data-side="my">
                <strong>ÏÉÅÎßàÏÉÅÎßà</strong>
                <small id="myFormationDesc1">b1=ÏÉÅ, c1=Îßà, g1=ÏÉÅ, h1=Îßà</small>
              </div>
              <div class="formation-option" data-formation="ÎßàÏÉÅÎßàÏÉÅ" data-side="my">
                <strong>ÎßàÏÉÅÎßàÏÉÅ</strong>
                <small id="myFormationDesc2">b1=Îßà, c1=ÏÉÅ, g1=Îßà, h1=ÏÉÅ</small>
              </div>
              <div class="formation-option selected" data-formation="ÎßàÏÉÅÏÉÅÎßà" data-side="my">
                <strong>ÎßàÏÉÅÏÉÅÎßà</strong>
                <small id="myFormationDesc3">b1=Îßà, c1=ÏÉÅ, g1=ÏÉÅ, h1=Îßà (Í∏∞Î≥∏Í∞í)</small>
              </div>
              <div class="formation-option" data-formation="ÏÉÅÎßàÎßàÏÉÅ" data-side="my">
                <strong>ÏÉÅÎßàÎßàÏÉÅ</strong>
                <small id="myFormationDesc4">b1=ÏÉÅ, c1=Îßà, g1=Îßà, h1=ÏÉÅ</small>
              </div>
            </div>
          </div>

          <div style="margin-bottom: 24px;">
            <h4 style="color: #c9a66b; margin-bottom: 12px; font-size: 16px; font-weight: 600;" id="opponentFormationLabel">ÏÉÅÎåÄÏùò ÏÉÅÏ∞®Î¶º (Ï¥à Ï∏°)</h4>
            <div class="formation-selector" id="opponentFormationSelector">
              <div class="formation-option" data-formation="ÏÉÅÎßàÏÉÅÎßà" data-side="opponent">
                <strong>ÏÉÅÎßàÏÉÅÎßà</strong>
                <small id="opponentFormationDesc1">b10=ÏÉÅ, c10=Îßà, g10=ÏÉÅ, h10=Îßà</small>
              </div>
              <div class="formation-option" data-formation="ÎßàÏÉÅÎßàÏÉÅ" data-side="opponent">
                <strong>ÎßàÏÉÅÎßàÏÉÅ</strong>
                <small id="opponentFormationDesc2">b10=Îßà, c10=ÏÉÅ, g10=Îßà, h10=ÏÉÅ</small>
              </div>
              <div class="formation-option selected" data-formation="ÎßàÏÉÅÏÉÅÎßà" data-side="opponent">
                <strong>ÎßàÏÉÅÏÉÅÎßà</strong>
                <small id="opponentFormationDesc3">b10=Îßà, c10=ÏÉÅ, g10=ÏÉÅ, h10=Îßà (Í∏∞Î≥∏Í∞í)</small>
              </div>
              <div class="formation-option" data-formation="ÏÉÅÎßàÎßàÏÉÅ" data-side="opponent">
                <strong>ÏÉÅÎßàÎßàÏÉÅ</strong>
                <small id="opponentFormationDesc4">b10=ÏÉÅ, c10=Îßà, g10=Îßà, h10=ÏÉÅ</small>
              </div>
            </div>
          </div>

          <button id="applyFormationBtn" style="width: 100%">
            ÏÉÅÏ∞®Î¶º Ï†ÅÏö©
          </button>
        </div>

        <div class="side-panel history-panel">
          <h3>Ïù¥Îèô Í∏∞Î°ù</h3>
          <div id="moveHistory"></div>
        </div>
      </div>
    </div>

    <div class="toast-container" id="toastContainer"></div>

    <script>
      // ============================================
      // Canvas-based Janggi Board Renderer
      // ============================================

      const API_BASE = "/api";
      const GAME_ID = "default";

      // Canvas and context
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Board dimensions (base values, will be scaled for responsive)
      const BASE_CANVAS_WIDTH = 520;
      const BASE_CANVAS_HEIGHT = 580;
      let CANVAS_WIDTH = BASE_CANVAS_WIDTH;
      let CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      let PADDING = 40;
      let CELL_WIDTH = (CANVAS_WIDTH - PADDING * 2) / 8;
      let CELL_HEIGHT = (CANVAS_HEIGHT - PADDING * 2) / 9;
      let PIECE_RADIUS = 24;
      let scaleFactor = 1;

      // Game state
      let boardData = [];
      let boardKorean = [];
      let legalMoves = [];
      let selectedSquare = null;
      let possibleMoveSquares = [];
      let lastMoveFrom = null;
      let lastMoveTo = null;
      let inCheckSquare = null;
      let hoverSquare = null;
      let boardFlipped = false; // Î≥¥Îìú Îí§ÏßëÍ∏∞ ÏÉÅÌÉú
      let mySide = "han"; // ÎÇ¥ ÏßÑÏòÅ: "cho" ÎòêÎäî "han"
      let isGameOver = false; // Í≤åÏûÑ Ï¢ÖÎ£å ÏÉÅÌÉú
      let isAutoPlaying = false; // AI ÏûêÎèô ÏßÑÌñâ Ï§ë Ïó¨Î∂Ä
      let canUndo = false; // Ïàò ÎêòÎèåÎ¶¨Í∏∞ Í∞ÄÎä• Ïó¨Î∂Ä
      let inOpeningBook = false; // Ïò§ÌîÑÎãù Î∂Å ÏÉÅÌÉú

      // Animation state
      let animatingPiece = null;
      let particles = [];
      let selectionPulse = 0;
      let possibleMovePulse = 0;
      let pieceAppearAnimations = [];
      let isAnimationLoopRunning = false;
      let lastFrameTime = 0;

      // Colors
      const COLORS = {
        boardBg: "#c9a66b",
        boardLine: "#3d2914",
        palaceLine: "#3d2914",
        pieceBase: "#faf6e8",
        pieceBorder: "#2d2d2d",
        hanColor: "#c41e3a",
        choColor: "#1a5fb4",
        selectedGlow: "#90ee90",
        possibleMove: "rgba(74, 144, 226, 0.6)",
        captureMove: "rgba(220, 53, 69, 0.7)",
        lastMoveFrom: "rgba(255, 215, 0, 0.4)",
        lastMoveTo: "rgba(50, 205, 50, 0.4)",
        checkGlow: "#ff0000",
        hoverGlow: "rgba(255, 255, 255, 0.4)",
      };

      // ============================================
      // Easing functions
      // ============================================

      const Easing = {
        // Smooth deceleration
        easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
        
        // Bounce at end
        easeOutBounce: (t) => {
          const n1 = 7.5625;
          const d1 = 2.75;
          if (t < 1 / d1) return n1 * t * t;
          if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
          if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
          return n1 * (t -= 2.625 / d1) * t + 0.984375;
        },
        
        // Elastic bounce
        easeOutElastic: (t) => {
          if (t === 0 || t === 1) return t;
          return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1;
        },
        
        // Back overshoot
        easeOutBack: (t) => {
          const c1 = 1.70158;
          const c3 = c1 + 1;
          return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
        },
        
        // Smooth start and end
        easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
      };

      // ============================================
      // Responsive canvas sizing
      // ============================================

      function resizeCanvas() {
        const container = document.querySelector('.board-wrapper');
        const maxWidth = Math.min(container.clientWidth - 40, BASE_CANVAS_WIDTH);
        
        // Only resize if significantly different (prevent constant redraws)
        if (Math.abs(maxWidth - CANVAS_WIDTH) > 10) {
          scaleFactor = maxWidth / BASE_CANVAS_WIDTH;
          CANVAS_WIDTH = maxWidth;
          CANVAS_HEIGHT = BASE_CANVAS_HEIGHT * scaleFactor;
          PADDING = 40 * scaleFactor;
          CELL_WIDTH = (CANVAS_WIDTH - PADDING * 2) / 8;
          CELL_HEIGHT = (CANVAS_HEIGHT - PADDING * 2) / 9;
          PIECE_RADIUS = 24 * scaleFactor;
          
          canvas.width = CANVAS_WIDTH;
          canvas.height = CANVAS_HEIGHT;
          canvas.style.width = CANVAS_WIDTH + 'px';
          canvas.style.height = CANVAS_HEIGHT + 'px';
          
          // Redraw
          if (boardData.length > 0) {
            render(performance.now());
          }
        }
      }

      // Debounced resize handler
      let resizeTimeout;
      function handleResize() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(resizeCanvas, 150);
      }

      window.addEventListener('resize', handleResize);

      // ============================================
      // Coordinate conversion functions
      // ============================================

      function fileRankToPixel(file, rank) {
        // Î≥¥ÎìúÍ∞Ä Îí§ÏßëÌûå Í≤ΩÏö∞: ÌååÏùºÍ≥º Îû≠ÌÅ¨Î•º Î∞òÎåÄÎ°ú Î≥ÄÌôò
        let displayFile = boardFlipped ? (8 - file) : file;
        let displayRank = boardFlipped ? (9 - rank) : rank;
        
        const x = PADDING + displayFile * CELL_WIDTH;
        const y = PADDING + (9 - displayRank) * CELL_HEIGHT;
        return { x, y };
      }

      function pixelToFileRank(px, py) {
        const displayFile = Math.round((px - PADDING) / CELL_WIDTH);
        const rankFromTop = Math.round((py - PADDING) / CELL_HEIGHT);
        let displayRank = 9 - rankFromTop;

        // Î≥¥ÎìúÍ∞Ä Îí§ÏßëÌûå Í≤ΩÏö∞: ÌôîÎ©¥ Ï¢åÌëúÎ•º Ïã§Ï†ú Î≥¥Îìú Ï¢åÌëúÎ°ú Î≥ÄÌôò
        const file = boardFlipped ? (8 - displayFile) : displayFile;
        const rank = boardFlipped ? (9 - displayRank) : displayRank;

        if (file >= 0 && file <= 8 && rank >= 0 && rank <= 9) {
          return { file, rank };
        }
        return null;
      }

      function squareToNotation(file, rank) {
        return String.fromCharCode(97 + file) + (rank + 1);
      }

      // ============================================
      // Particle System
      // ============================================

      class Particle {
        constructor(x, y, color, type = 'burst') {
          this.x = x;
          this.y = y;
          this.color = color;
          this.type = type;
          this.life = 1;
          this.decay = 0.02 + Math.random() * 0.02;
          
          if (type === 'burst') {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 4;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.size = 3 + Math.random() * 5;
            this.gravity = 0.15;
          } else if (type === 'sparkle') {
            this.vx = (Math.random() - 0.5) * 2;
            this.vy = -1 - Math.random() * 2;
            this.size = 2 + Math.random() * 3;
            this.gravity = 0.05;
          } else if (type === 'ring') {
            this.radius = 0;
            this.maxRadius = 40 + Math.random() * 20;
            this.decay = 0.03;
          }
        }

        update() {
          this.life -= this.decay;
          
          if (this.type === 'burst' || this.type === 'sparkle') {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.vx *= 0.98;
            this.size *= 0.97;
          } else if (this.type === 'ring') {
            this.radius += (this.maxRadius - this.radius) * 0.1;
          }
          
          return this.life > 0;
        }

        draw(ctx) {
          ctx.globalAlpha = this.life;
          
          if (this.type === 'burst' || this.type === 'sparkle') {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
          } else if (this.type === 'ring') {
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 3 * this.life;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.stroke();
          }
          
          ctx.globalAlpha = 1;
        }
      }

      function createCaptureEffect(x, y, isHan) {
        const color = isHan ? COLORS.hanColor : COLORS.choColor;
        const colors = [color, '#ffd700', '#ffffff'];
        
        // Burst particles
        for (let i = 0; i < 15; i++) {
          particles.push(new Particle(x, y, colors[Math.floor(Math.random() * colors.length)], 'burst'));
        }
        
        // Sparkles
        for (let i = 0; i < 8; i++) {
          particles.push(new Particle(x, y, '#ffffff', 'sparkle'));
        }
        
        // Expanding ring
        particles.push(new Particle(x, y, color, 'ring'));
      }

      function createMoveTrail(x, y, color) {
        for (let i = 0; i < 3; i++) {
          const p = new Particle(x, y, color, 'sparkle');
          p.decay = 0.05;
          p.size = 2;
          particles.push(p);
        }
      }

      // ============================================
      // Drawing functions
      // ============================================

      function drawBoard() {
        // Clear canvas
        ctx.fillStyle = COLORS.boardBg;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        ctx.strokeStyle = COLORS.boardLine;
        ctx.lineWidth = 1.5;

        // Draw horizontal lines
        for (let i = 0; i < 10; i++) {
          const y = PADDING + i * CELL_HEIGHT;
          ctx.beginPath();
          ctx.moveTo(PADDING, y);
          ctx.lineTo(CANVAS_WIDTH - PADDING, y);
          ctx.stroke();
        }

        // Draw vertical lines
        for (let i = 0; i < 9; i++) {
          const x = PADDING + i * CELL_WIDTH;
          ctx.beginPath();
          ctx.moveTo(x, PADDING);
          ctx.lineTo(x, CANVAS_HEIGHT - PADDING);
          ctx.stroke();
        }

        // Draw palace diagonals
        ctx.strokeStyle = COLORS.palaceLine;

        // Top palace
        const topPalace = {
          left: fileRankToPixel(3, 9),
          right: fileRankToPixel(5, 9),
          bottomLeft: fileRankToPixel(3, 7),
          bottomRight: fileRankToPixel(5, 7),
        };

        ctx.beginPath();
        ctx.moveTo(topPalace.left.x, topPalace.left.y);
        ctx.lineTo(topPalace.bottomRight.x, topPalace.bottomRight.y);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(topPalace.right.x, topPalace.right.y);
        ctx.lineTo(topPalace.bottomLeft.x, topPalace.bottomLeft.y);
        ctx.stroke();

        // Bottom palace
        const bottomPalace = {
          left: fileRankToPixel(3, 2),
          right: fileRankToPixel(5, 2),
          bottomLeft: fileRankToPixel(3, 0),
          bottomRight: fileRankToPixel(5, 0),
        };

        ctx.beginPath();
        ctx.moveTo(bottomPalace.left.x, bottomPalace.left.y);
        ctx.lineTo(bottomPalace.bottomRight.x, bottomPalace.bottomRight.y);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(bottomPalace.right.x, bottomPalace.right.y);
        ctx.lineTo(bottomPalace.bottomLeft.x, bottomPalace.bottomLeft.y);
        ctx.stroke();
      }

      function drawHighlights(deltaTime) {
        // Update pulse values
        selectionPulse += deltaTime * 0.004;
        possibleMovePulse += deltaTime * 0.003;

        // Draw last move highlights with fade effect
        if (lastMoveFrom) {
          const { x, y } = fileRankToPixel(lastMoveFrom.file, lastMoveFrom.rank);
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, PIECE_RADIUS + 10);
          gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
          gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(x, y, PIECE_RADIUS + 10, 0, Math.PI * 2);
          ctx.fill();
        }

        if (lastMoveTo) {
          const { x, y } = fileRankToPixel(lastMoveTo.file, lastMoveTo.rank);
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, PIECE_RADIUS + 10);
          gradient.addColorStop(0, 'rgba(50, 205, 50, 0.3)');
          gradient.addColorStop(1, 'rgba(50, 205, 50, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(x, y, PIECE_RADIUS + 10, 0, Math.PI * 2);
          ctx.fill();
        }

        // Draw possible moves with animated pulse
        possibleMoveSquares.forEach((sq, index) => {
          const { x, y } = fileRankToPixel(sq.file, sq.rank);
          const hasPiece = getPieceAt(sq.file, sq.rank);
          const pulseOffset = index * 0.3;
          const pulse = Math.sin(possibleMovePulse + pulseOffset) * 0.3 + 0.7;

          if (hasPiece) {
            // Capture indicator - animated ring
            const ringPulse = Math.sin(possibleMovePulse * 2 + pulseOffset) * 0.2 + 0.8;
            ctx.strokeStyle = `rgba(220, 53, 69, ${ringPulse})`;
            ctx.lineWidth = 3 + Math.sin(possibleMovePulse + pulseOffset) * 1;
            ctx.beginPath();
            ctx.arc(x, y, PIECE_RADIUS + 5 + Math.sin(possibleMovePulse + pulseOffset) * 2, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner glow
            const gradient = ctx.createRadialGradient(x, y, PIECE_RADIUS - 5, x, y, PIECE_RADIUS + 8);
            gradient.addColorStop(0, 'rgba(220, 53, 69, 0)');
            gradient.addColorStop(1, `rgba(220, 53, 69, ${0.2 * ringPulse})`);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, PIECE_RADIUS + 8, 0, Math.PI * 2);
            ctx.fill();
          } else {
            // Empty square - animated filled circle
            const size = 10 + Math.sin(possibleMovePulse + pulseOffset) * 3;
            ctx.fillStyle = `rgba(74, 144, 226, ${0.5 * pulse})`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Outer ring
            ctx.strokeStyle = `rgba(74, 144, 226, ${0.3 * pulse})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, size + 5, 0, Math.PI * 2);
            ctx.stroke();
          }
        });

        // Draw selection highlight with pulse
        if (selectedSquare) {
          const { x, y } = fileRankToPixel(selectedSquare.file, selectedSquare.rank);
          const pulse = Math.sin(selectionPulse * 2) * 0.3 + 0.7;
          const glowSize = PIECE_RADIUS + 6 + Math.sin(selectionPulse * 2) * 3;
          
          // Outer glow
          const gradient = ctx.createRadialGradient(x, y, PIECE_RADIUS, x, y, glowSize + 10);
          gradient.addColorStop(0, `rgba(144, 238, 144, ${0.4 * pulse})`);
          gradient.addColorStop(1, 'rgba(144, 238, 144, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(x, y, glowSize + 10, 0, Math.PI * 2);
          ctx.fill();
          
          // Main ring
          ctx.strokeStyle = `rgba(144, 238, 144, ${pulse})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(x, y, glowSize, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Draw hover highlight
        if (hoverSquare && !selectedSquare) {
          const piece = getPieceAt(hoverSquare.file, hoverSquare.rank);
          if (piece) {
            const { x, y } = fileRankToPixel(hoverSquare.file, hoverSquare.rank);
            ctx.strokeStyle = COLORS.hoverGlow;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, PIECE_RADIUS + 4, 0, Math.PI * 2);
            ctx.stroke();
          }
        }

        // Draw check indicator
        if (inCheckSquare) {
          const { x, y } = fileRankToPixel(inCheckSquare.file, inCheckSquare.rank);
          const time = Date.now() / 300;
          const pulse = Math.sin(time) * 0.4 + 0.6;
          const glowSize = PIECE_RADIUS + 8 + Math.sin(time) * 4;

          // Danger gradient
          const gradient = ctx.createRadialGradient(x, y, PIECE_RADIUS - 5, x, y, glowSize + 15);
          gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
          gradient.addColorStop(0.5, `rgba(255, 0, 0, ${0.3 * pulse})`);
          gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(x, y, glowSize + 15, 0, Math.PI * 2);
          ctx.fill();

          // Pulsing ring
          ctx.strokeStyle = `rgba(255, 0, 0, ${pulse})`;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(x, y, glowSize, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      function drawPiece(file, rank, pieceData, koreanData, options = {}) {
        const {
          scale = 1,
          offsetX = 0,
          offsetY = 0,
          alpha = 1,
          shadowScale = 1,
          rotation = 0
        } = options;

        // Ensure scale is positive to prevent negative radius
        const safeScale = Math.max(0.01, scale);
        
        const { x, y } = fileRankToPixel(file, rank);
        const drawX = x + offsetX;
        const drawY = y + offsetY;
        const radius = PIECE_RADIUS * safeScale;

        const isHan = pieceData[0] === "h";
        const pieceColor = isHan ? COLORS.hanColor : COLORS.choColor;

        ctx.save();
        ctx.globalAlpha = alpha;
        
        if (rotation !== 0) {
          ctx.translate(drawX, drawY);
          ctx.rotate(rotation);
          ctx.translate(-drawX, -drawY);
        }

        // Draw piece shadow (larger when hovering/moving)
        const shadowOffset = 2 + (shadowScale - 1) * 4;
        const shadowBlur = 3 + (shadowScale - 1) * 8;
        ctx.fillStyle = `rgba(0, 0, 0, ${0.3 * shadowScale})`;
        ctx.beginPath();
        ctx.arc(drawX + shadowOffset, drawY + shadowOffset + (shadowScale - 1) * 3, radius, 0, Math.PI * 2);
        ctx.fill();

        // Draw piece background with gradient
        const gradient = ctx.createRadialGradient(
          drawX - radius * 0.3,
          drawY - radius * 0.3,
          0,
          drawX,
          drawY,
          radius
        );
        gradient.addColorStop(0, "#fffef8");
        gradient.addColorStop(0.7, "#f5f0e0");
        gradient.addColorStop(1, "#e8e0d0");

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(drawX, drawY, radius, 0, Math.PI * 2);
        ctx.fill();

        // Draw piece border
        ctx.strokeStyle = pieceColor;
        ctx.lineWidth = 2.5 * safeScale;
        ctx.beginPath();
        ctx.arc(drawX, drawY, Math.max(1, radius - 1), 0, Math.PI * 2);
        ctx.stroke();

        // Inner subtle border (only if radius is big enough)
        if (radius > 5) {
          ctx.strokeStyle = `rgba(${isHan ? '196, 30, 58' : '26, 95, 180'}, 0.3)`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(drawX, drawY, radius - 4, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Draw piece character
        if (koreanData && koreanData.name) {
          ctx.fillStyle = pieceColor;
          ctx.font = `bold ${Math.floor(22 * safeScale)}px "Noto Serif KR", serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          
          // Text shadow
          ctx.fillStyle = `rgba(0, 0, 0, 0.2)`;
          ctx.fillText(koreanData.name, drawX + 1, drawY + 2);
          
          // Main text
          ctx.fillStyle = pieceColor;
          ctx.fillText(koreanData.name, drawX, drawY + 1);
        }

        ctx.restore();
      }

      function drawPieces(deltaTime) {
        if (!boardData || boardData.length === 0) return;

        // Update appear animations
        pieceAppearAnimations = pieceAppearAnimations.filter(anim => {
          anim.progress += deltaTime / anim.duration;
          return anim.progress < 1;
        });

        for (let rankIdx = 0; rankIdx < 10; rankIdx++) {
          for (let fileIdx = 0; fileIdx < 9; fileIdx++) {
            const piece = boardData[rankIdx]?.[fileIdx];
            if (!piece) continue;

            const rank = 9 - rankIdx;
            
            // Skip animating piece
            if (animatingPiece && animatingPiece.fromFile === fileIdx && animatingPiece.fromRank === rank) {
              continue;
            }

            const koreanData = boardKorean[rankIdx]?.[fileIdx];
            
            // Check for appear animation
            const appearAnim = pieceAppearAnimations.find(
              a => a.file === fileIdx && a.rank === rank
            );
            
            // Check if this piece is being hovered
            const isHovered = hoverSquare && hoverSquare.file === fileIdx && hoverSquare.rank === rank;
            const isSelected = selectedSquare && selectedSquare.file === fileIdx && selectedSquare.rank === rank;
            
            let options = {};
            
            if (appearAnim) {
              // Skip if animation hasn't started yet (progress < 0 means waiting for delay)
              if (appearAnim.progress < 0) {
                continue; // Don't draw this piece yet
              }
              // Use easeOutCubic instead of easeOutBack to avoid negative values
              const t = Easing.easeOutCubic(Math.min(1, appearAnim.progress));
              // Ensure scale is never negative or zero
              const safeScale = Math.max(0.01, t);
              options = {
                scale: safeScale,
                alpha: Math.max(0, t),
                offsetY: (1 - t) * -30
              };
            } else if (isSelected) {
              // Selected piece floats slightly
              const float = Math.sin(selectionPulse * 2) * 2;
              options = {
                offsetY: -3 + float,
                shadowScale: 1.3
              };
            } else if (isHovered && !selectedSquare) {
              // Hovered piece lifts up
              options = {
                offsetY: -4,
                shadowScale: 1.2
              };
            }

            drawPiece(fileIdx, rank, piece, koreanData, options);
          }
        }

        // Draw animating piece on top
        if (animatingPiece) {
          drawPiece(
            animatingPiece.fromFile,
            animatingPiece.fromRank,
            animatingPiece.piece,
            animatingPiece.korean,
            {
              scale: animatingPiece.scale,
              offsetX: animatingPiece.offsetX,
              offsetY: animatingPiece.offsetY,
              shadowScale: animatingPiece.shadowScale,
              rotation: animatingPiece.rotation || 0
            }
          );
        }
      }

      function drawParticles() {
        particles = particles.filter(p => {
          p.draw(ctx);
          return p.update();
        });
      }

      function getPieceAt(file, rank) {
        const rankIdx = 9 - rank;
        return boardData[rankIdx]?.[file] || null;
      }

      // ============================================
      // Main render loop
      // ============================================

      function render(timestamp = 0) {
        // Clamp deltaTime to prevent huge jumps on first frame or after tab switch
        let deltaTime = timestamp - lastFrameTime;
        if (deltaTime > 100) deltaTime = 16; // Cap at ~60fps equivalent
        lastFrameTime = timestamp;

        drawBoard();
        drawHighlights(deltaTime);
        drawPieces(deltaTime);
        drawParticles();

        // Continue animation loop if needed
        if (needsAnimation()) {
          requestAnimationFrame(render);
        } else {
          isAnimationLoopRunning = false;
        }
      }

      function needsAnimation() {
        return animatingPiece !== null ||
               particles.length > 0 ||
               pieceAppearAnimations.length > 0 ||
               selectedSquare !== null ||
               possibleMoveSquares.length > 0 ||
               inCheckSquare !== null;
      }

      function startAnimationLoop() {
        if (!isAnimationLoopRunning) {
          isAnimationLoopRunning = true;
          lastFrameTime = performance.now();
          requestAnimationFrame(render);
        }
      }

      // ============================================
      // Move Animation System
      // ============================================

      function animateMove(fromFile, fromRank, toFile, toRank, capturedPiece, callback) {
        const piece = getPieceAt(fromFile, fromRank);
        if (!piece) {
          if (callback) callback();
          return;
        }

        const fromRankIdx = 9 - fromRank;
        const korean = boardKorean[fromRankIdx]?.[fromFile];
        const isHan = piece[0] === 'h';

        const fromPos = fileRankToPixel(fromFile, fromRank);
        const toPos = fileRankToPixel(toFile, toRank);
        
        // Calculate distance for duration
        const dx = toPos.x - fromPos.x;
        const dy = toPos.y - fromPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const duration = Math.min(400, Math.max(200, distance * 1.2));

        const startTime = performance.now();

        // Calculate arc height based on distance
        const arcHeight = Math.min(50, distance * 0.3);

        animatingPiece = {
          piece,
          korean,
          fromFile,
          fromRank,
          offsetX: 0,
          offsetY: 0,
          scale: 1,
          shadowScale: 1,
          rotation: 0
        };

        function animate(currentTime) {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);

          // Position with arc trajectory
          const linearProgress = Easing.easeOutCubic(progress);
          animatingPiece.offsetX = dx * linearProgress;
          
          // Parabolic arc for Y
          const arcProgress = progress;
          const arc = -4 * arcHeight * arcProgress * (arcProgress - 1);
          animatingPiece.offsetY = dy * linearProgress - arc;

          // Scale: slightly larger during flight, then settle
          if (progress < 0.5) {
            animatingPiece.scale = 1 + Easing.easeOutCubic(progress * 2) * 0.15;
            animatingPiece.shadowScale = 1 + progress * 0.6;
          } else {
            animatingPiece.scale = 1.15 - Easing.easeOutBounce((progress - 0.5) * 2) * 0.15;
            animatingPiece.shadowScale = 1.3 - (progress - 0.5) * 0.6;
          }

          // Slight rotation during movement
          animatingPiece.rotation = Math.sin(progress * Math.PI) * 0.1;

          // Create trail particles
          if (progress < 0.8 && Math.random() < 0.3) {
            const trailX = fromPos.x + animatingPiece.offsetX;
            const trailY = fromPos.y + animatingPiece.offsetY;
            createMoveTrail(trailX, trailY, isHan ? COLORS.hanColor : COLORS.choColor);
          }

          render(currentTime);

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Landing effect
            if (capturedPiece) {
              createCaptureEffect(toPos.x, toPos.y, capturedPiece[0] === 'h');
            }
            
            animatingPiece = null;
            startAnimationLoop();
            if (callback) callback();
          }
        }

        requestAnimationFrame(animate);
      }

      // ============================================
      // Piece Appear Animation
      // ============================================

      function animatePiecesAppear() {
        pieceAppearAnimations = [];
        
        for (let rankIdx = 0; rankIdx < 10; rankIdx++) {
          for (let fileIdx = 0; fileIdx < 9; fileIdx++) {
            const piece = boardData[rankIdx]?.[fileIdx];
            if (piece) {
              const rank = 9 - rankIdx;
              // Calculate delay based on distance from center
              const distFromCenter = Math.abs(rank - 4.5) + Math.abs(fileIdx - 4);
              const delay = distFromCenter * 20; // Reduced delay multiplier
              
              pieceAppearAnimations.push({
                file: fileIdx,
                rank: rank,
                progress: -delay / 400, // Start in negative (waiting state)
                duration: 350
              });
            }
          }
        }
        
        startAnimationLoop();
      }

      // ============================================
      // Game logic
      // ============================================

      async function initGame(formation = null, hanFormation = null, choFormation = null) {
        try {
          const body = {
            game_id: GAME_ID,
            depth: 3,
            use_nnue: true,
          };
          
          // Backward compatibility: if formation is provided, use it for both sides
          if (formation) {
            body.formation = formation;
          } else if (hanFormation || choFormation) {
            // Use separate formations
            if (hanFormation) body.han_formation = hanFormation;
            if (choFormation) body.cho_formation = choFormation;
          }
          
          const response = await fetch(`${API_BASE}/new-game`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          if (response.ok) {
            clearSelection();
            lastMoveFrom = null;
            lastMoveTo = null;
            isGameOver = false; // Í≤åÏûÑ Ï¢ÖÎ£å ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            isAutoPlaying = false; // ÏûêÎèô ÏßÑÌñâ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            document.getElementById("aiMoveBtn").disabled = false; // AI Î≤ÑÌäº ÌôúÏÑ±Ìôî
            updateAutoPlayButton(); // ÏûêÎèô ÏßÑÌñâ Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            await updateBoard(true);
          }
        } catch (error) {
          console.error("Failed to initialize game:", error);
          showToast("Í≤åÏûÑ Ï¥àÍ∏∞Ìôî Ïã§Ìå®", "error");
        }
      }

      async function updateBoard(animateAppear = false) {
        try {
          const response = await fetch(`${API_BASE}/board/${GAME_ID}`);
          const data = await response.json();

          boardData = data.board || [];
          boardKorean = data.board_korean || [];
          legalMoves = data.legal_moves || [];
          
          // Í≤åÏûÑ Ï¢ÖÎ£å ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
          isGameOver = data.game_over || false;
          
          // Undo ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
          canUndo = data.can_undo || false;
          updateUndoButton();
          
          // Ïò§ÌîÑÎãù Î∂Å ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
          inOpeningBook = data.in_opening_book || false;
          updateBookIndicator();
          
          // Í≤åÏûÑÏù¥ Ï¢ÖÎ£åÎêòÎ©¥ AI Ïù¥Îèô Î≤ÑÌäº ÎπÑÌôúÏÑ±Ìôî Î∞è ÏûêÎèô ÏßÑÌñâ Ï§ëÏßÄ
          document.getElementById("aiMoveBtn").disabled = isGameOver;
          if (isGameOver && isAutoPlaying) {
            isAutoPlaying = false;
            updateAutoPlayButton();
          }
          updateAutoPlayButton();

          updateStatus(data);
          updateMoveHistory(data.move_history || []);

          // Find king in check
          inCheckSquare = null;
          if (data.in_check) {
            const kingChar = data.side_to_move === "HAN" ? "hK" : "cK";
            for (let rankIdx = 0; rankIdx < 10; rankIdx++) {
              for (let fileIdx = 0; fileIdx < 9; fileIdx++) {
                if (boardData[rankIdx]?.[fileIdx] === kingChar) {
                  inCheckSquare = { file: fileIdx, rank: 9 - rankIdx };
                  break;
                }
              }
              if (inCheckSquare) break;
            }
          }

          if (animateAppear) {
            animatePiecesAppear();
          } else {
            startAnimationLoop();
            render(performance.now());
          }
        } catch (error) {
          console.error("Failed to update board:", error);
        }
      }

      function clearSelection() {
        selectedSquare = null;
        possibleMoveSquares = [];
        document.getElementById("moveInfo").style.display = "none";
        startAnimationLoop();
      }

      function selectSquare(file, rank) {
        const piece = getPieceAt(file, rank);
        if (!piece) return;

        selectedSquare = { file, rank };
        const squareKey = squareToNotation(file, rank);

        const movesFromSquare = legalMoves.filter((m) => m.from === squareKey);
        possibleMoveSquares = movesFromSquare.map((m) => {
          const toFile = m.to.charCodeAt(0) - 97;
          const toRank = parseInt(m.to.slice(1)) - 1;
          return { file: toFile, rank: toRank };
        });

        const rankIdx = 9 - rank;
        const korean = boardKorean[rankIdx]?.[file];
        if (korean) {
          document.getElementById("moveInfo").style.display = "block";
          document.getElementById("selectedPiece").textContent =
            korean.full_name || korean.name;
          document.getElementById("possibleMoves").textContent =
            movesFromSquare.length > 0
              ? movesFromSquare.map((m) => m.to).join(", ")
              : "ÏóÜÏùå";
        }

        startAnimationLoop();
      }

      async function makeMove(fromFile, fromRank, toFile, toRank) {
        const fromSquare = squareToNotation(fromFile, fromRank);
        const toSquare = squareToNotation(toFile, toRank);
        
        // Check if there's a piece to capture
        const capturedPiece = getPieceAt(toFile, toRank);

        try {
          const moveResponse = await fetch(`${API_BASE}/move`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              game_id: GAME_ID,
              from_square: fromSquare,
              to_square: toSquare,
            }),
          });

          if (moveResponse.ok) {
            const result = await moveResponse.json();
            
            lastMoveFrom = { file: fromFile, rank: fromRank };
            lastMoveTo = { file: toFile, rank: toRank };

            animateMove(fromFile, fromRank, toFile, toRank, capturedPiece, async () => {
              clearSelection();
              await updateBoard();
              
              // Î¨¥ÏäπÎ∂Ä Ï≤òÎ¶¨
              if (result.game_over && result.winner === null) {
                if (result.reason === "draw_by_repetition") {
                  showToast("ÎèôÏùº Íµ≠Î©¥ 3Ìöå Î∞òÎ≥µÏúºÎ°ú Î¨¥ÏäπÎ∂ÄÏûÖÎãàÎã§!", "warning", 5000);
                } else {
                  showToast("Î¨¥ÏäπÎ∂ÄÏûÖÎãàÎã§!", "warning", 5000);
                }
              }
            });
          } else {
            const error = await moveResponse.json();
            showToast(`Î∂àÎ≤ïÏàò: ${error.detail}`, "error");
            clearSelection();
          }
        } catch (error) {
          console.error("Failed to make move:", error);
          clearSelection();
        }
      }

      async function aiMove() {
        // Í≤åÏûÑÏù¥ Ï¢ÖÎ£åÎêú Í≤ΩÏö∞ AI Ïù¥Îèô Î∂àÍ∞Ä
        if (isGameOver) {
          showToast("Í≤åÏûÑÏù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§. ÏÉà Í≤åÏûÑÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî.", "warning");
          return;
        }
        
        try {
          const response = await fetch(`${API_BASE}/ai-move/${GAME_ID}`, {
            method: "POST",
          });

          if (response.ok) {
            const data = await response.json();

            const fromFile = data.move.from.charCodeAt(0) - 97;
            const fromRank = parseInt(data.move.from.slice(1)) - 1;
            const toFile = data.move.to.charCodeAt(0) - 97;
            const toRank = parseInt(data.move.to.slice(1)) - 1;
            
            const capturedPiece = getPieceAt(toFile, toRank);

            lastMoveFrom = { file: fromFile, rank: fromRank };
            lastMoveTo = { file: toFile, rank: toRank };

            animateMove(fromFile, fromRank, toFile, toRank, capturedPiece, async () => {
              await updateBoard();
              
              // Î¨¥ÏäπÎ∂Ä Ï≤òÎ¶¨
              if (data.game_over && data.winner === null) {
                if (data.reason === "draw_by_repetition") {
                  showToast("ÎèôÏùº Íµ≠Î©¥ 3Ìöå Î∞òÎ≥µÏúºÎ°ú Î¨¥ÏäπÎ∂ÄÏûÖÎãàÎã§!", "warning", 5000);
                } else {
                  showToast("Î¨¥ÏäπÎ∂ÄÏûÖÎãàÎã§!", "warning", 5000);
                }
              } else {
                const bookInfo = data.from_opening_book ? " üìñ" : "";
                document.getElementById("status").textContent = 
                  `AI: ${data.move.from} ‚Üí ${data.move.to} (${data.nodes_searched} nodes)${bookInfo}`;
                document.getElementById("status").className = "status info";
              }
              
              // ÏûêÎèô ÏßÑÌñâ Ï§ëÏù¥Î©¥ Îã§Ïùå Ïàò ÏßÑÌñâ
              if (isAutoPlaying && !data.game_over) {
                // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏôÑÎ£å ÌõÑ ÏïΩÍ∞ÑÏùò ÎîúÎ†àÏù¥Î•º ÎëêÍ≥† Îã§Ïùå Ïàò ÏßÑÌñâ
                setTimeout(() => {
                  if (isAutoPlaying && !isGameOver) {
                    aiMove();
                  }
                }, 500);
              }
            });
            
            // Í≤åÏûÑ Ï¢ÖÎ£å Ïãú ÏûêÎèô ÏßÑÌñâ Ï§ëÏßÄ
            if (data.game_over) {
              isAutoPlaying = false;
              updateAutoPlayButton();
            }
          } else {
            const error = await response.json();
            showToast(`AI Ïù¥Îèô Ïã§Ìå®: ${error.detail}`, "error");
            // ÏóêÎü¨ Î∞úÏÉù Ïãú ÏûêÎèô ÏßÑÌñâ Ï§ëÏßÄ
            isAutoPlaying = false;
            updateAutoPlayButton();
          }
        } catch (error) {
          console.error("Failed to get AI move:", error);
          showToast("AI Ïù¥Îèô Ï§ë Ïò§Î•ò Î∞úÏÉù", "error");
          // ÏóêÎü¨ Î∞úÏÉù Ïãú ÏûêÎèô ÏßÑÌñâ Ï§ëÏßÄ
          isAutoPlaying = false;
          updateAutoPlayButton();
        }
      }
      
      async function toggleAutoPlay() {
        if (isGameOver) {
          showToast("Í≤åÏûÑÏù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§. ÏÉà Í≤åÏûÑÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî.", "warning");
          return;
        }
        
        if (isAutoPlaying) {
          // ÏûêÎèô ÏßÑÌñâ Ï§ëÏßÄ
          isAutoPlaying = false;
          updateAutoPlayButton();
          showToast("AI ÏûêÎèô ÏßÑÌñâÏù¥ Ï§ëÏßÄÎêòÏóàÏäµÎãàÎã§.", "info");
        } else {
          // ÏûêÎèô ÏßÑÌñâ ÏãúÏûë
          isAutoPlaying = true;
          updateAutoPlayButton();
          showToast("AI ÏûêÎèô ÏßÑÌñâÏùÑ ÏãúÏûëÌï©ÎãàÎã§.", "info");
          // Ï≤´ Ïàò ÏãúÏûë
          await aiMove();
        }
      }
      
      function updateAutoPlayButton() {
        const btn = document.getElementById("autoPlayBtn");
        if (isAutoPlaying) {
          btn.textContent = "ÏûêÎèô ÏßÑÌñâ Ï§ëÏßÄ";
          btn.classList.add("error");
          btn.classList.remove("secondary");
        } else {
          btn.textContent = "AI ÏûêÎèô ÏßÑÌñâ";
          btn.classList.remove("error");
          btn.classList.add("secondary");
        }
        btn.disabled = isGameOver;
      }

      function updateUndoButton() {
        const btn = document.getElementById("undoBtn");
        btn.disabled = !canUndo || isAutoPlaying;
      }

      function updateBookIndicator() {
        const indicator = document.getElementById("bookIndicator");
        if (inOpeningBook) {
          indicator.style.display = "inline-flex";
          indicator.classList.remove("inactive");
          indicator.innerHTML = "üìñ Ï†ïÏÑùÎ∂Å";
        } else {
          indicator.classList.add("inactive");
          indicator.innerHTML = "üìñ Ï†ïÏÑùÎ∂Å Ï¢ÖÎ£å";
          // Í≤åÏûÑÏù¥ Î™á Ïàò ÏßÑÌñâÎêêÏùÑ ÎïåÎßå ÌëúÏãú
          if (boardData.length > 0) {
            indicator.style.display = "inline-flex";
          }
        }
      }

      async function undoMove() {
        if (!canUndo || isAutoPlaying) {
          showToast("ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.", "warning");
          return;
        }

        try {
          // Îëê Ïàò ÎêòÎèåÎ¶¨Í∏∞ (ÎÇ¥ Ïàò + AI Ïàò)
          const response = await fetch(`${API_BASE}/undo/${GAME_ID}`, {
            method: "POST",
          });

          if (response.ok) {
            clearSelection();
            lastMoveFrom = null;
            lastMoveTo = null;
            await updateBoard();
            showToast("ÏàòÎ•º ÎêòÎèåÎ†∏ÏäµÎãàÎã§.", "success");
          } else {
            const error = await response.json();
            showToast(`ÎêòÎèåÎ¶¨Í∏∞ Ïã§Ìå®: ${error.detail}`, "error");
          }
        } catch (error) {
          console.error("Failed to undo move:", error);
          showToast("ÎêòÎèåÎ¶¨Í∏∞ Ï§ë Ïò§Î•ò Î∞úÏÉù", "error");
        }
      }

      async function undoMovePair() {
        if (!canUndo || isAutoPlaying) {
          showToast("ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.", "warning");
          return;
        }

        try {
          // Îëê Ïàò ÎêòÎèåÎ¶¨Í∏∞ (ÎÇ¥ Ïàò + AI Ïàò)
          const response = await fetch(`${API_BASE}/undo-pair/${GAME_ID}`, {
            method: "POST",
          });

          if (response.ok) {
            clearSelection();
            lastMoveFrom = null;
            lastMoveTo = null;
            await updateBoard();
            showToast("Îëê ÏàòÎ•º ÎêòÎèåÎ†∏ÏäµÎãàÎã§.", "success");
          } else {
            // Ìïú ÏàòÎßå ÎêòÎèåÎ¶¨Í∏∞ ÏãúÎèÑ
            await undoMove();
          }
        } catch (error) {
          console.error("Failed to undo move pair:", error);
          // Ìïú ÏàòÎßå ÎêòÎèåÎ¶¨Í∏∞ ÏãúÎèÑ
          await undoMove();
        }
      }

      function updateStatus(data) {
        const statusEl = document.getElementById("status");

        if (data.game_over) {
          if (data.winner) {
            // ÏäπÌå®Í∞Ä Í≤∞Ï†ïÎêú Í≤ΩÏö∞
            const winnerName = data.winner === "HAN" ? "Ìïú" : "Ï¥à";
            statusEl.textContent = `Í≤åÏûÑ Ï¢ÖÎ£å! ${winnerName} Ï∏° ÏäπÎ¶¨!`;
            statusEl.className = "status success";
          } else {
            // Î¨¥ÏäπÎ∂ÄÏù∏ Í≤ΩÏö∞
            if (data.draw_reason === "repetition") {
              statusEl.textContent = `Í≤åÏûÑ Ï¢ÖÎ£å! Î¨¥ÏäπÎ∂Ä (ÎèôÏùº Íµ≠Î©¥ 3Ìöå Î∞òÎ≥µ)`;
            } else {
              statusEl.textContent = `Í≤åÏûÑ Ï¢ÖÎ£å! Î¨¥ÏäπÎ∂Ä`;
            }
            statusEl.className = "status warning";
          }
        } else if (data.in_check) {
          const sideName = data.side_to_move === "HAN" ? "Ìïú" : "Ï¥à";
          statusEl.textContent = `${sideName} Ï∏°Ïù¥ Ïû•Íµ∞ ÏÉÅÌÉúÏûÖÎãàÎã§!`;
          statusEl.className = "status warning";
        } else {
          const sideName = data.side_to_move === "HAN" ? "Ìïú" : "Ï¥à";
          statusEl.textContent = `ÌòÑÏû¨ Ï∞®Î°Ä: ${sideName}`;
          statusEl.className = "status info";
        }
      }

      function updateMoveHistory(history) {
        const historyEl = document.getElementById("moveHistory");
        historyEl.innerHTML = "";

        history.forEach((move) => {
          const item = document.createElement("div");
          item.className = "history-item";
          if (move.captured) {
            item.classList.add("capture");
          }
          item.innerHTML = `<strong>${move.move_number}.</strong> ${move.notation}`;
          historyEl.appendChild(item);
        });

        historyEl.scrollTop = historyEl.scrollHeight;
      }

      // ============================================
      // Event handlers
      // ============================================

      canvas.addEventListener("click", (e) => {
        if (animatingPiece) return; // Ignore clicks during animation
        if (isGameOver) return; // Í≤åÏûÑÏù¥ Ï¢ÖÎ£åÎêòÎ©¥ ÌÅ¥Î¶≠ Î¨¥Ïãú

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const px = (e.clientX - rect.left) * scaleX;
        const py = (e.clientY - rect.top) * scaleY;

        const pos = pixelToFileRank(px, py);
        if (!pos) return;

        const { file, rank } = pos;

        if (selectedSquare) {
          const isPossibleMove = possibleMoveSquares.some(
            (sq) => sq.file === file && sq.rank === rank
          );

          if (isPossibleMove) {
            makeMove(selectedSquare.file, selectedSquare.rank, file, rank);
          } else if (file === selectedSquare.file && rank === selectedSquare.rank) {
            clearSelection();
          } else {
            const piece = getPieceAt(file, rank);
            if (piece) {
              selectSquare(file, rank);
            } else {
              clearSelection();
            }
          }
        } else {
          selectSquare(file, rank);
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const px = (e.clientX - rect.left) * scaleX;
        const py = (e.clientY - rect.top) * scaleY;

        const pos = pixelToFileRank(px, py);

        if (pos) {
          const newHover = { file: pos.file, rank: pos.rank };
          if (!hoverSquare || hoverSquare.file !== newHover.file || hoverSquare.rank !== newHover.rank) {
            hoverSquare = newHover;
            if (!isAnimationLoopRunning) {
              render(performance.now());
            }
          }
        } else {
          if (hoverSquare) {
            hoverSquare = null;
            if (!isAnimationLoopRunning) {
              render(performance.now());
            }
          }
        }
      });

      canvas.addEventListener("mouseleave", () => {
        if (hoverSquare) {
          hoverSquare = null;
          if (!isAnimationLoopRunning) {
            render(performance.now());
          }
        }
      });

      // ============================================
      // Toast notifications
      // ============================================

      function showToast(message, type = "info", duration = 3000) {
        const container = document.getElementById("toastContainer");
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;

        const icons = {
          error: "‚ö†Ô∏è",
          success: "‚úì",
          info: "‚ÑπÔ∏è",
          warning: "‚ö†Ô∏è",
        };

        toast.innerHTML = `
          <span class="toast-icon">${icons[type] || icons.info}</span>
          <span class="toast-content">${message}</span>
          <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
        `;

        container.appendChild(toast);

        setTimeout(() => {
          toast.classList.add("hiding");
          setTimeout(() => {
            if (toast.parentElement) {
              toast.remove();
            }
          }, 300);
        }, duration);
      }

      // ============================================
      // UI controls
      // ============================================

      function toggleSetupPanel() {
        const panel = document.getElementById("setupPanel");
        const isOpening = panel.style.display === "none";
        panel.style.display = isOpening ? "block" : "none";
        if (isOpening) {
          updateFormationLabels();
        }
      }

      // ÏÉÅÏ∞®Î¶º Ï¢åÏö∞ Î∞òÏ†Ñ Ìï®Ïàò (ÏÇ¨Ïö©ÏûêÍ∞Ä Î≥¥Îäî Í¥ÄÏ†êÏóêÏÑú Ïã§Ï†ú Î≥¥Îìú Ï¢åÌëúÎ°ú Î≥ÄÌôò)
      function flipFormation(formation) {
        // ÏÉÅÏ∞®Î¶º Ï¢åÏö∞ Î∞òÏ†Ñ Îß§Ìïë: b1‚Üîh1, c1‚Üîg1
        const flipMap = {
          "ÏÉÅÎßàÏÉÅÎßà": "ÎßàÏÉÅÎßàÏÉÅ",  // b1=ÏÉÅ, c1=Îßà, g1=ÏÉÅ, h1=Îßà ‚Üí b1=Îßà, c1=ÏÉÅ, g1=Îßà, h1=ÏÉÅ
          "ÎßàÏÉÅÎßàÏÉÅ": "ÏÉÅÎßàÏÉÅÎßà",  // b1=Îßà, c1=ÏÉÅ, g1=Îßà, h1=ÏÉÅ ‚Üí b1=ÏÉÅ, c1=Îßà, g1=ÏÉÅ, h1=Îßà
          "ÎßàÏÉÅÏÉÅÎßà": "ÎßàÏÉÅÏÉÅÎßà",  // ÎåÄÏπ≠Ïù¥ÎØÄÎ°ú ÎèôÏùº
          "ÏÉÅÎßàÎßàÏÉÅ": "ÏÉÅÎßàÎßàÏÉÅ",  // ÎåÄÏπ≠Ïù¥ÎØÄÎ°ú ÎèôÏùº
        };
        return flipMap[formation] || formation;
      }

      // UI Î†àÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
      function updateFormationLabels() {
        const mySideLabel = mySide === "cho" ? "Ï¥à" : "Ìïú";
        const opponentSideLabel = mySide === "cho" ? "Ìïú" : "Ï¥à";
        const myRank = mySide === "cho" ? "10" : "1";
        const opponentRank = mySide === "cho" ? "1" : "10";
        
        document.getElementById("myFormationLabel").textContent = `ÎÇòÏùò ÏÉÅÏ∞®Î¶º (${mySideLabel} Ï∏°)`;
        document.getElementById("opponentFormationLabel").textContent = `ÏÉÅÎåÄÏùò ÏÉÅÏ∞®Î¶º (${opponentSideLabel} Ï∏°)`;
        
        // ÎÇ¥ ÏÉÅÏ∞®Î¶º ÏÑ§Î™Ö ÏóÖÎç∞Ïù¥Ìä∏
        document.getElementById("myFormationDesc1").textContent = `b${myRank}=ÏÉÅ, c${myRank}=Îßà, g${myRank}=ÏÉÅ, h${myRank}=Îßà`;
        document.getElementById("myFormationDesc2").textContent = `b${myRank}=Îßà, c${myRank}=ÏÉÅ, g${myRank}=Îßà, h${myRank}=ÏÉÅ`;
        document.getElementById("myFormationDesc3").textContent = `b${myRank}=Îßà, c${myRank}=ÏÉÅ, g${myRank}=ÏÉÅ, h${myRank}=Îßà (Í∏∞Î≥∏Í∞í)`;
        document.getElementById("myFormationDesc4").textContent = `b${myRank}=ÏÉÅ, c${myRank}=Îßà, g${myRank}=Îßà, h${myRank}=ÏÉÅ`;
        
        // ÏÉÅÎåÄ ÏÉÅÏ∞®Î¶º ÏÑ§Î™Ö ÏóÖÎç∞Ïù¥Ìä∏
        document.getElementById("opponentFormationDesc1").textContent = `b${opponentRank}=ÏÉÅ, c${opponentRank}=Îßà, g${opponentRank}=ÏÉÅ, h${opponentRank}=Îßà`;
        document.getElementById("opponentFormationDesc2").textContent = `b${opponentRank}=Îßà, c${opponentRank}=ÏÉÅ, g${opponentRank}=Îßà, h${opponentRank}=ÏÉÅ`;
        document.getElementById("opponentFormationDesc3").textContent = `b${opponentRank}=Îßà, c${opponentRank}=ÏÉÅ, g${opponentRank}=ÏÉÅ, h${opponentRank}=Îßà (Í∏∞Î≥∏Í∞í)`;
        document.getElementById("opponentFormationDesc4").textContent = `b${opponentRank}=ÏÉÅ, c${opponentRank}=Îßà, g${opponentRank}=Îßà, h${opponentRank}=ÏÉÅ`;
      }

      async function applyFormation() {
        const mySelected = document.querySelector("#myFormationSelector .formation-option.selected");
        const opponentSelected = document.querySelector("#opponentFormationSelector .formation-option.selected");
        
        if (!mySelected || !opponentSelected) {
          showToast("ÏÉÅÏ∞®Î¶ºÏùÑ Î™®Îëê ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.", "warning");
          return;
        }

        let myFormation = mySelected.dataset.formation;
        let opponentFormation = opponentSelected.dataset.formation;
        
        // ÏÇ¨Ïö©ÏûêÍ∞Ä Î≥¥Îäî Í¥ÄÏ†êÏóêÏÑú Ïã§Ï†ú Î≥¥Îìú Ï¢åÌëúÎ°ú Î≥ÄÌôò
        // ÎÇ¥Í∞Ä Ï¥àÏù¥Í≥† Ìïú ÏßÑÏòÅÏùÑ Î≥¥Îäî Í≤ΩÏö∞, ÎòêÎäî ÎÇ¥Í∞Ä ÌïúÏù¥Í≥† Ï¥à ÏßÑÏòÅÏùÑ Î≥¥Îäî Í≤ΩÏö∞ Ï¢åÏö∞ Î∞òÏ†Ñ ÌïÑÏöî
        let hanFormation, choFormation;
        
        if (mySide === "cho") {
          // ÎÇ¥Í∞Ä Ï¥à: ÎÇ¥ ÏÉÅÏ∞®Î¶ºÏùÄ Ï¥à ÏßÑÏòÅ, ÏÉÅÎåÄ ÏÉÅÏ∞®Î¶ºÏùÄ Ìïú ÏßÑÏòÅ
          choFormation = myFormation; // ÎÇ¥Í∞Ä Î≥¥Îäî Ï¥à ÏßÑÏòÅÏùÄ Í∑∏ÎåÄÎ°ú
          hanFormation = flipFormation(opponentFormation); // ÎÇ¥Í∞Ä Î≥¥Îäî Ìïú ÏßÑÏòÅÏùÄ Ï¢åÏö∞ Î∞òÏ†Ñ
        } else {
          // ÎÇ¥Í∞Ä Ìïú: ÎÇ¥ ÏÉÅÏ∞®Î¶ºÏùÄ Ìïú ÏßÑÏòÅ, ÏÉÅÎåÄ ÏÉÅÏ∞®Î¶ºÏùÄ Ï¥à ÏßÑÏòÅ
          hanFormation = myFormation; // ÎÇ¥Í∞Ä Î≥¥Îäî Ìïú ÏßÑÏòÅÏùÄ Í∑∏ÎåÄÎ°ú
          choFormation = flipFormation(opponentFormation); // ÎÇ¥Í∞Ä Î≥¥Îäî Ï¥à ÏßÑÏòÅÏùÄ Ï¢åÏö∞ Î∞òÏ†Ñ
        }
        
        await initGame(null, hanFormation, choFormation);
        toggleSetupPanel();
        const mySideLabel = mySide === "cho" ? "Ï¥à" : "Ìïú";
        const opponentSideLabel = mySide === "cho" ? "Ìïú" : "Ï¥à";
        showToast(`${mySideLabel}: ${myFormation}, ${opponentSideLabel}: ${opponentFormation} ÏÉÅÏ∞®Î¶ºÏúºÎ°ú Í≤åÏûÑÏùÑ ÏãúÏûëÌï©ÎãàÎã§!`, "success");
      }

      // ÎÇ¥ ÏßÑÏòÅ ÏÑ†ÌÉù Ïù¥Î≤§Ìä∏
      document.querySelectorAll("#mySideSelector .formation-option").forEach((option) => {
        option.addEventListener("click", () => {
          document.querySelectorAll("#mySideSelector .formation-option").forEach((opt) => {
            opt.classList.remove("selected");
          });
          option.classList.add("selected");
          mySide = option.dataset.side;
          updateFormationLabels();
        });
      });

      // ÎÇ¥ ÏÉÅÏ∞®Î¶º ÏÑ†ÌÉù Ïù¥Î≤§Ìä∏
      document.querySelectorAll("#myFormationSelector .formation-option").forEach((option) => {
        option.addEventListener("click", () => {
          document.querySelectorAll("#myFormationSelector .formation-option").forEach((opt) => {
            opt.classList.remove("selected");
          });
          option.classList.add("selected");
        });
      });

      // ÏÉÅÎåÄ ÏÉÅÏ∞®Î¶º ÏÑ†ÌÉù Ïù¥Î≤§Ìä∏
      document.querySelectorAll("#opponentFormationSelector .formation-option").forEach((option) => {
        option.addEventListener("click", () => {
          document.querySelectorAll("#opponentFormationSelector .formation-option").forEach((opt) => {
            opt.classList.remove("selected");
          });
          option.classList.add("selected");
        });
      });

      // ============================================
      // Board flip functionality
      // ============================================

      function flipBoard() {
        boardFlipped = !boardFlipped;
        // Î≤ÑÌäº ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
        const flipBtn = document.getElementById("flipBoardBtn");
        flipBtn.textContent = boardFlipped ? "Î≥¥Îìú ÎêòÎèåÎ¶¨Í∏∞" : "Î≥¥Îìú Îí§ÏßëÍ∏∞";
        // Î≥¥ÎìúÍ∞Ä Îí§ÏßëÌûàÎ©¥ ÏÑ†ÌÉù ÏÉÅÌÉúÏôÄ ÌïòÏù¥ÎùºÏù¥Ìä∏ÎèÑ Îã§Ïãú Í∑∏Î†§Ïïº Ìï®
        startAnimationLoop();
        render(performance.now());
      }

      // Button event listeners
      document.getElementById("newGameBtn").addEventListener("click", () => initGame());
      document.getElementById("aiMoveBtn").addEventListener("click", aiMove);
      document.getElementById("autoPlayBtn").addEventListener("click", toggleAutoPlay);
      document.getElementById("undoBtn").addEventListener("click", undoMovePair);
      document.getElementById("setupBtn").addEventListener("click", toggleSetupPanel);
      document.getElementById("applyFormationBtn").addEventListener("click", applyFormation);
      document.getElementById("flipBoardBtn").addEventListener("click", flipBoard);

      // Initialize on load
      updateFormationLabels();
      updateAutoPlayButton(); // Ï¥àÍ∏∞ Î≤ÑÌäº ÏÉÅÌÉú ÏÑ§Ï†ï
      updateUndoButton(); // Ï¥àÍ∏∞ undo Î≤ÑÌäº ÏÉÅÌÉú ÏÑ§Ï†ï
      resizeCanvas(); // Ï¥àÍ∏∞ Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÏÑ§Ï†ï
      initGame();
    </script>
  </body>
</html>
